<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.554">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Tiny few shot classifer</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="Tiny_Few_Shot_Classifier_files/libs/clipboard/clipboard.min.js"></script>
<script src="Tiny_Few_Shot_Classifier_files/libs/quarto-html/quarto.js"></script>
<script src="Tiny_Few_Shot_Classifier_files/libs/quarto-html/popper.min.js"></script>
<script src="Tiny_Few_Shot_Classifier_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Tiny_Few_Shot_Classifier_files/libs/quarto-html/anchor.min.js"></script>
<link href="Tiny_Few_Shot_Classifier_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Tiny_Few_Shot_Classifier_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Tiny_Few_Shot_Classifier_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Tiny_Few_Shot_Classifier_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Tiny_Few_Shot_Classifier_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>
<script src="https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js" crossorigin="anonymous"></script>


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Tiny few shot classifer</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Im folgenden wird ein few shot classifier im <a href="https://huggingface.co/blog/setfit">SetFit-Frame</a> work erzeugt.</p>
<section id="vorteile-von-setfit" class="level2">
<h2 class="anchored" data-anchor-id="vorteile-von-setfit">Vorteile von SetFit</h2>
<p>Die Verwendung von SetFit (Sentence Transformer Fine-tuning) hat mehrere Vorteile für die hiesige Anwendung:</p>
<ol type="1">
<li><p><strong>Few-Shot-Learning</strong>: SetFit wurde speziell entwickelt, um mit sehr wenigen Trainingsbeispielen pro Klasse zu arbeiten (z. B. 8 Beispiele). Das Modell erreicht dennoch eine hohe Genauigkeit, was es ideal für Anwendungsfälle mit begrenzten annotierten Daten macht.</p></li>
<li><p><strong>Effiziente Fine-Tuning-Methode</strong>: Anstatt ein großes Sprachmodell vollständig zu trainieren, verwendet SetFit einen zweistufigen Ansatz. Zuerst wird ein vortrainiertes Sentence Transformer-Modell (z. B. MiniLM) auf die Textdaten angepasst, dann wird ein einfacher Klassifikator darauf angewendet. Dies ist sowohl rechen- als auch speichereffizient.</p></li>
<li><p><strong>Keine zusätzliche Tokenisierung</strong>: SetFit arbeitet direkt mit Sentence Embeddings, was bedeutet, dass keine zusätzliche Tokenisierung oder Verarbeitung für die Fine-Tuning-Aufgabe erforderlich ist. Dies vereinfacht den Einsatz und spart Rechenressourcen.</p></li>
<li><p><strong>Gute Performance bei kleinerem Modell</strong>: Durch die Verwendung von kompakten Sentence Transformers kann SetFit eine hohe Genauigkeit erreichen, ohne die Ressourcenanforderungen eines größeren Modells zu benötigen.</p></li>
<li><p><strong>Schnelle Anpassung</strong>: Aufgrund des effizienten Fine-Tuning-Prozesses kann SetFit in kürzerer Zeit auf neue Datensätze angepasst werden, was es für den produktiven Einsatz in schnell wechselnden Umgebungen geeignet macht.</p></li>
</ol>
</section>
<section id="berechnung-des-few-shot-modells" class="level1">
<h1>Berechnung des few shot Modells</h1>
<section id="lade-bibliotheken" class="level2">
<h2 class="anchored" data-anchor-id="lade-bibliotheken">Lade Bibliotheken</h2>
<p>Folgende Bibliotheken werden geladen:</p>
<ul>
<li><p><code>from datasets import load_dataset</code>: Zum Laden von Datensätzen aus der HuggingFace <code>datasets</code> Bibliothek, z.B. öffentliche oder lokale Datensätze.</p></li>
<li><p><code>from sentence_transformers.losses import CosineSimilarityLoss</code>: Wird verwendet, um einen <em>Cosine Similarity Loss</em> für das Training von sentence-transformers-Modellen zu definieren (z.B. bei Ähnlichkeitsvergleichen zwischen Textpaaren).</p></li>
<li><p><code>from setfit import SetFitModel, SetFitTrainer</code>:</p>
<ul>
<li><strong>SetFitModel</strong>: Ein Modell aus dem SetFit-Framework, das für Zero-Shot- oder Few-Shot-Learning verwendet wird.</li>
<li><strong>SetFitTrainer</strong>: Trainer-Klasse, die verwendet wird, um das SetFit-Modell auf spezifische Aufgaben zu trainieren.</li>
</ul></li>
<li><p><code>import pandas as pd</code>: Für die Data-Wrangling</p></li>
<li><p><code>from sklearn.preprocessing import LabelEncoder</code>: Zum Kodieren von Zielvariablen (Labels) in numerische Form. Besonders nützlich, wenn die Labels in string-Format vorliegen und in Zahlen umgewandelt werden müssen, um sie einem Modell zu übergeben.</p></li>
<li><p><code>import os</code>: Ermöglicht die Interaktion mit dem Betriebssystem, wie z.B. den Zugriff auf Dateipfade, Erstellen von Ordnern oder Lesen von Umgebungsvariablen.</p></li>
<li><p><code>from datasets import Dataset, DatasetDict</code>:</p>
<ul>
<li><strong>Dataset</strong>: Klasse, um einen benutzerdefinierten Datensatz für die Verwendung mit der <code>datasets</code> Bibliothek zu erstellen.</li>
<li><strong>DatasetDict</strong>: Zum Organisieren und Verwalten mehrerer Datensätze (z.B. <code>train</code> und <code>test</code>).</li>
</ul></li>
<li><p><code>from sklearn.model_selection import train_test_split</code>: Zum Aufteilen eines Datensatzes in Trainings- und Testdaten. Diese Methode wird oft verwendet, um Modelle zu validieren und zu evaluieren.</p></li>
<li><p><code>from transformers import TrainingArguments</code>: Legt die Trainingsparameter für Modelle aus der HuggingFace Transformers Bibliothek fest (z.B. Anzahl der Epochen, Batch-Größe, Optimierungsparameter etc.).</p></li>
</ul>
<div id="cell-2" class="cell" data-execution_count="51">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> datasets <span class="im">import</span> load_dataset</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sentence_transformers.losses <span class="im">import</span> CosineSimilarityLoss</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> setfit <span class="im">import</span> SetFitModel, SetFitTrainer</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> LabelEncoder</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> datasets <span class="im">import</span> Dataset, DatasetDict</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> train_test_split</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> transformers <span class="im">import</span> TrainingArguments</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch <span class="co">#für gpu-nutzung</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="daten" class="level2">
<h2 class="anchored" data-anchor-id="daten">Daten</h2>
<section id="lade-daten" class="level3">
<h3 class="anchored" data-anchor-id="lade-daten">Lade Daten</h3>
<p>Um die Daten zu laden wird in einem ersten Schritt das Root-Verzeichnis ausgelesen und ggf. angepasst:</p>
<div id="cell-4" class="cell" data-execution_count="52">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># checke home-verzeichnis</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(os.getcwd())</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co"># setze home-verzeichnis</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>os.chdir(<span class="st">'c:/Users/Hueck/OneDrive/Dokumente/GitHub/future_skill_classification/'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>c:\Users\Hueck\OneDrive\Dokumente\GitHub\future_skill_classification</code></pre>
</div>
</div>
<div id="cell-5" class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Select N examples per class (8 in this case)</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(torch.cuda.is_available())  <span class="co"># Sollte True ausgeben, wenn CUDA verfügbar ist</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(torch.cuda.get_device_name(<span class="dv">0</span>))  <span class="co"># Zeigt den Namen deiner GPU an</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>True
NVIDIA GeForce RTX 4060 Ti</code></pre>
</div>
</div>
<p>Stimmt das Verzeichnis, kann im folgenden der Datensatz geladen werden. Wir laden die Daten und schauen uns die ersten</p>
<div id="cell-7" class="cell" data-execution_count="53">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Laden Ihrer Excel-Datei</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.read_excel(<span class="st">'data/fs_test_data.xlsx'</span>)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>df.head()</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>df.info()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 637 entries, 0 to 636
Data columns (total 3 columns):
 #   Column                  Non-Null Count  Dtype 
---  ------                  --------------  ----- 
 0   titel_kursbeschreibung  637 non-null    object
 1   label_num               637 non-null    int64 
 2   label_text              637 non-null    object
dtypes: int64(1), object(2)
memory usage: 15.1+ KB</code></pre>
</div>
</div>
</section>
<section id="erzeuge-test--und-trainingsdaten" class="level3">
<h3 class="anchored" data-anchor-id="erzeuge-test--und-trainingsdaten">Erzeuge Test- und Trainingsdaten</h3>
<p>Im folgenden wird der Datensatz für das Training und die Evaluierung des Clasifiers vorbereitet.</p>
<ol type="1">
<li><p>Der Data Frame wird in zwei Teile geteilt: Trainingsdaten (train_df) und Testdaten (test_df). 20% der Daten werden für den Testdatensatz verwendet, während 80% als Trainingsdatensatz verwendet werden. Mit <code>random_state=42</code> wird sicher gestellt, dass die Aufteilung reproduzierbar ist. <code>stratify=df['label']</code> sichert schließlich, dass die Verteilung der Zielvariable (label) im Training- und Testdatensatz bleibt, wie im Ursprungsdatensatz <code>df</code>.</p></li>
<li><p>Dataset.from_pandas(): train_df.reset_index(drop=True) und test_df.reset_index(drop=True): Zuerst wird der Index des DataFrames zurückgesetzt, damit keine alte Indexspalte übernommen wird. Das drop=True sorgt dafür, dass der alte Index vollständig entfernt wird. Dataset.from_pandas(): Diese Methode konvertiert den Pandas DataFrame (train_df und test_df) in ein Dataset-Objekt aus der HuggingFace datasets-Bibliothek, das besser geeignet ist für den Einsatz in NLP-Pipelines.</p></li>
</ol>
<div id="cell-9" class="cell" data-execution_count="55">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Aufteilen des DataFrames</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>train_df, test_df <span class="op">=</span> train_test_split(df, test_size<span class="op">=</span><span class="fl">0.2</span>, random_state<span class="op">=</span><span class="dv">42</span>, stratify<span class="op">=</span>df[<span class="st">'label_num'</span>])</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Konvertieren in Datasets</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>train_dataset <span class="op">=</span> Dataset.from_pandas(train_df.reset_index(drop<span class="op">=</span><span class="va">True</span>))</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>test_dataset <span class="op">=</span> Dataset.from_pandas(test_df.reset_index(drop<span class="op">=</span><span class="va">True</span>))</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Erstellen eines DatasetDicts</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>dataset_dict <span class="op">=</span> DatasetDict({</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="st">'train'</span>: train_dataset,</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    <span class="st">'test'</span>: test_dataset</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="modell-und-trainer-initialisieren" class="level2">
<h2 class="anchored" data-anchor-id="modell-und-trainer-initialisieren">Modell und Trainer initialisieren</h2>
<p>Zunächst werden die Klassen <code>SetFitModel</code> und <code>SetFitTrainer</code> aus der <code>SetFit</code>-Bibliothek importiert. <code>SetFit</code> basiert auf der sentence-transformers-Architektur und ist speziell für effiziente Few-Shot-Klassifikationsaufgaben konzipiert.</p>
<p>Mit <code>paraphrase-mpnet-base-v2</code> wird ein vortrainiertes Modell geladen, das auf der MPNet-Architektur basiert und darauf spezialisiert ist, semantische Ähnlichkeiten zwischen Texten zu erkennen. Die MPNet-Architektur ist ein Sprachmodell, das darauf trainiert wird, den Kontext und die Bedeutung von Wörtern in einem Satz besser zu verstehen. Es maskiert (versteckt) einige Wörter und versucht, diese anhand des restlichen Satzes vorherzusagen, um so die Bedeutung zu erfassen. Zusätzlich permutiert (vertauscht) es die Reihenfolge der Wörter, um die Wechselwirkungen zwischen ihnen zu lernen. Dadurch kann MPNet komplexe Satzstrukturen und den Sinn von Texten sehr präzise analysieren.</p>
<div id="cell-11" class="cell" data-execution_count="56">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> setfit <span class="im">import</span> SetFitModel, SetFitTrainer</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> SetFitModel.from_pretrained(<span class="st">"sentence-transformers/paraphrase-mpnet-base-v2"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>model_head.pkl not found on HuggingFace Hub, initialising classification head with random weights. You should TRAIN this model on a downstream task to use it for predictions and inference.</code></pre>
</div>
</div>
<p>Als nächstes wird getestet, ob eine GPU (CUDA) vorhanden ist. Ist dies der Fall, wird das Modell mit Hilfe der GPU berechnet. Weiterhin werden folgende Parameter spezifiziert:</p>
<ul>
<li><p><strong><code>SetFitTrainer</code>:</strong> Dies ist ein Trainer-Objekt, das den gesamten Trainingsprozess steuert, einschließlich der Festlegung der Trainingsdaten, der Verlustfunktion und der Trainingsparameter.</p></li>
<li><p><strong><code>Modell</code>:</strong> Das Modell, das trainiert wird, ist ein vortrainiertes Sprachmodell, das an die aktuelle Aufgabe angepasst wird.</p></li>
<li><p><strong><code>Trainings- und Testdatensatz</code>:</strong> <code>train_dataset</code> und <code>eval_dataset</code> sind die Datensätze, die zum Training und zur Evaluierung des Modells verwendet werden. Der Trainingsdatensatz dient dem Lernen, während der Testdatensatz die Modellleistung prüft.</p></li>
<li><p><strong><code>CosineSimilarityLoss</code>:</strong> Eine Verlustfunktion, die den Kosinus-Abstand zwischen Satzpaaren misst, um die Ähnlichkeit zwischen ihnen zu bewerten. Sie hilft dem Modell, besser darin zu werden, ähnliche Texte zu erkennen und zu klassifizieren.</p></li>
<li><p><strong><code>batch_size</code>:</strong> Die Anzahl der Beispiele, die das Modell in einem Durchlauf verarbeitet, bevor es die Modellparameter aktualisiert. Größere Batches können zu stabileren Aktualisierungen führen, benötigen jedoch mehr Speicher.</p></li>
<li><p><strong><code>num_iterations</code>:</strong> Die Anzahl der Textpaarungen, die pro Beispiel während des Trainings erstellt werden. Mehr Iterationen können zu einer besseren Generalisierung des Modells führen.</p></li>
<li><p><strong><code>num_epochs</code>:</strong> Die Anzahl der kompletten Durchläufe durch den gesamten Trainingsdatensatz. Mehr Epochen können zu einer verbesserten Modellleistung führen, erhöhen jedoch auch die Trainingszeit.</p></li>
<li><p><strong><code>column_mapping</code>:</strong> Hier wird festgelegt, welche Spalten des Datensatzes als Texte (<code>"titel_kursbeschreibung"</code>) und als Labels (<code>"label_num"</code>) verwendet werden sollen. Dies ist wichtig, um dem Modell die Struktur des Datensatzes verständlich zu machen.</p></li>
</ul>
<div id="cell-13" class="cell" data-execution_count="57">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Sicherstellen, dass CUDA verfügbar ist und Gerät festlegen</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>training_device <span class="op">=</span> torch.device(<span class="st">"cuda"</span>) <span class="cf">if</span> torch.cuda.is_available() <span class="cf">else</span> torch.device(<span class="st">"cpu"</span>)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Modell auf die GPU verschieben</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> model.to(training_device)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialisieren des Trainers mit den Trainingsargumenten</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>trainer <span class="op">=</span> SetFitTrainer(</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    model<span class="op">=</span>model, </span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    train_dataset<span class="op">=</span>dataset_dict[<span class="st">'train'</span>],</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    eval_dataset<span class="op">=</span>dataset_dict[<span class="st">'test'</span>],</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    loss_class<span class="op">=</span>CosineSimilarityLoss,</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    batch_size<span class="op">=</span><span class="dv">16</span>,</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    num_iterations<span class="op">=</span><span class="dv">10</span>,  <span class="co"># Anzahl der Textpaarungen pro Beispiel</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    num_epochs<span class="op">=</span><span class="dv">1</span>,        <span class="co"># Anzahl der Epochen</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    column_mapping<span class="op">=</span>{<span class="st">"titel_kursbeschreibung"</span>: <span class="st">"text"</span>, <span class="st">"label_num"</span>: <span class="st">"label"</span>}</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>C:\Users\Hueck\AppData\Local\Temp\ipykernel_15616\3209044073.py:13: DeprecationWarning: `SetFitTrainer` has been deprecated and will be removed in v2.0.0 of SetFit. Please use `Trainer` instead.
  trainer = SetFitTrainer(
Applying column mapping to the training dataset
Applying column mapping to the evaluation dataset
c:\Users\Hueck\AppData\Local\Programs\Python\Python312\Lib\site-packages\datasets\utils\_dill.py:379: DeprecationWarning: co_lnotab is deprecated, use co_lines instead.
  obj.co_lnotab,  # for &lt; python 3.10 [not counted in args]</code></pre>
</div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"709c90f84bf84383a3366ca74ca3aced","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
</div>
<p>Nun wird das Training induziert:</p>
<div id="cell-15" class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>trainer.train()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>***** Running training *****
  Num unique pairs = 10180
  Batch size = 16
  Num epochs = 1</code></pre>
</div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"36f7c50f7b9d4c54b4cafc101351ec03","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>{'embedding_loss': 0.2519, 'grad_norm': 2.2817471027374268, 'learning_rate': 3.125e-07, 'epoch': 0.0}
{'embedding_loss': 0.2065, 'grad_norm': 1.211120843887329, 'learning_rate': 1.5625e-05, 'epoch': 0.08}
{'embedding_loss': 0.1206, 'grad_norm': 2.5888679027557373, 'learning_rate': 1.87434554973822e-05, 'epoch': 0.16}
{'embedding_loss': 0.062, 'grad_norm': 1.6714777946472168, 'learning_rate': 1.699825479930192e-05, 'epoch': 0.24}</code></pre>
</div>
</div>
</section>
<section id="evaluieren-des-modells" class="level2">
<h2 class="anchored" data-anchor-id="evaluieren-des-modells">Evaluieren des Modells</h2>
<div id="cell-17" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> datasets</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>metrics <span class="op">=</span> trainer.evaluate()</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>metrics</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>***** Running evaluation *****</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="10">
<pre><code>{'accuracy': 0.39473684210526316}</code></pre>
</div>
</div>
<div id="cell-18" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>metrics</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="12">
<pre><code>{'accuracy': 0.39473684210526316}</code></pre>
</div>
</div>
</section>
</section>
<section id="upload-des-modells" class="level1">
<h1>Upload des Modells</h1>
<div id="cell-20" class="cell">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>trainer.push_to_hub(<span class="st">"fs-setfit-model"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>